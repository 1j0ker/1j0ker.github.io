<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-18T14:04:24.315Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>1j0ker</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>X-Forwarded-For 和 X-Real-IP 的一些理解与区别</title>
    <link href="http://yoursite.com/2019/07/15/X-Forward-f/"/>
    <id>http://yoursite.com/2019/07/15/X-Forward-f/</id>
    <published>2019-07-15T14:02:17.000Z</published>
    <updated>2019-07-18T14:04:24.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="X-Forwarded-For简单理解"><a href="#X-Forwarded-For简单理解" class="headerlink" title="X-Forwarded-For简单理解"></a>X-Forwarded-For简单理解</h1><h3 id="逐级记录代理信息"><a href="#逐级记录代理信息" class="headerlink" title="逐级记录代理信息"></a>逐级记录代理信息</h3><p>X-Forwarded-For 是一个 HTTP 扩展头部，用于让web服务器获取真实的用户的IP(但不一定是真实的，可被伪造，比如透明代理)；</p><p><strong>那为什么 Web 服务器只有通过 X-Forwarded-For 头才能获取真实的 IP？</strong><br>&#8195;这里用PHP说明一下， PHP后端获取用户ip会调用$_SERVER[‘REMOTE_ADDR’]，他表示的是和服务器握手的IP是什么(不可伪造)；<br>但假如用户使用代理来访问服务器，那么与服务器建立链接的IP就是 代理ip，并非用户的ip；<br>请求路径可以看做：<br><code>客户端 (--&gt; 正向代理 --&gt; 透明代理 --&gt; 服务器反向代理) --&gt; 服务器端</code><br>( )内的代理不是必须的；<br><br><br><strong>那么什么又是正向代理？透明代理？反向代理？</strong></p><ul><li>正向代理：一般企业在出口网关处设置代理（为了加速，节省流量）</li><li>透明代理：用户为了隐藏自己，自己设置代理（为了翻墙，这样就绕开了企业的正向代理）</li><li>反向代理：部署在Web服务器前面，为了负载均衡，保护内网服务器数据；</li></ul><p>那么下面几种情况：</p><ul><li>假如客户端直接连接 Web 服务器（假设 Web 服务器有公网地址），则$_SERVER[‘REMOTE_ADDR’] 获取到的是客户端的真实 IP ；</li><li>假设 Web 服务器前部署了反向代理（比如 Nginx），则 $_SERVER[‘REMOTE_ADDR’] 获取到的是反向代理设备的 IP（Nginx）；</li><li>假设客户端通过正向代理直接连接 Web 服务器（假设 Web 服务器有公网地址），则 $_SERVER[‘REMOTE_ADDR’] 获取到的正向代理设备的 IP ；</li></ul><p>所以就是由于各种代理的问题，$_SERVER[‘REMOTE_ADDR’] 获取到的 IP 是 Web 服务器 TCP 连接的 IP(不可伪造，web服务器不修改这个ip)，而并非用户真正的ip；</p><p>所以 <strong>X-Forwarded-For</strong>  出现了，它定义的协议头格式：<br>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-Forwarded-For: client, proxy1, proxy2</span><br></pre></td></tr></table></figure></p><p>client 表示用户的真实 IP，每经过一次代理服务器，代理服务器会在这个头里增加用户的 代理IP，但要注意的是，最后一个代理IP是不会添加到这个头里的，而是通过$_SERVER[‘REMOTE_ADDR’] 获取；</p><p>###example_1:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-Forwarded-For: 1.1.1.1, 2.2.2.2, 3.3.3.3</span><br></pre></td></tr></table></figure><p>原始ip:1.1.1.1 经过了 3 层代理访问当前服务器，第一层代理ip:2.2.2.2, 第二层代理ip:3.3.3.3, 第三层代理ip 也就是和服务端建立请求链接的ip:4.4.4.4;<br><br><br><strong>那接下来详细描述一下XFF的Proxy形成流程：</strong></p><ul><li>用户IP0 ——&gt; Proxy1（IP1）,Proxy1 记录用户的IP0 ，并将请求转发给Proxy2（IP2），并带上了HTTP Header X-Forward-For:IP0 ;</li><li>Proxy2接收到Proxy1的请求后，读取到有X-Forward-For头，那么就将Proxy1的IP1继续添加到X-Forward-For中，构成X-Forward-For:IP0, IP1 ;</li><li>同理，Proxy3 按照第二部构造出 X-Forwarded-For: IP0, IP1, IP2,转发给真正的服务器，比如NGINX，nginx收到了http请求，里面就是 X-Forwarded-For: IP0, IP1, IP2 这样的结果。所以Proxy 3 的IP3，不会出现在这里；</li><li>而Nginx只能通过 $remote_address 获取到，所以 $remote_address 获取的就是和服务器建立TCP链接的IP３（这个无法伪造）；</li></ul><p>很多项目通过获取 X-Forwarded-For 中首个IP作为真实IP。但是X-Forwarded-For可以伪造。</p><p>###Example2:</p><ul><li><strong>正常访问时：</strong></li></ul><p><em>！！！当X-Forward-For未使用安全设置，或者未使用<code>Real IP 模块</code></em>时；<br>在proxy1、proxy2、proxy3 的配置中都加上：（实际proxy1、2、3在同一台机器，仅作测试）<br><code>proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</code><br>设置打印格式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log_format proxy1 '"[proxy1]" $remote_addr $proxy_add_x_forwarded_for "$request" $status';</span><br><span class="line">log_format proxy2 '"[proxy2]" $remote_addr $proxy_add_x_forwarded_for "$request" $status';</span><br><span class="line">log_format proxy3 '"[proxy3]" $remote_addr $proxy_add_x_forwarded_for "$request" $status';</span><br></pre></td></tr></table></figure><ul><li><code>$remote_addr</code>：与自身建立TCP链接的IP；</li><li><code>$proxy_add_x_forwarded_for</code>：打印XFF规则的IP；</li></ul><p>访问后，打印日志如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"[proxy1]" 123.123.123.123 123.123.123.123 "GET /hello HTTP/1.1" 200</span><br><span class="line">"[proxy2]" 1.1.1.1 123.123.123.123, 1.1.1.1 "GET /hello HTTP/1.0" 200</span><br><span class="line">"[proxy3]" 2.2.2.2 123.123.123.123, 1.1.1.1, 2.2.2.2 "GET /hello HTTP/1.0" 200</span><br></pre></td></tr></table></figure><p>（<strong>123.123.123.123为我的真实IP</strong>）<br>因此，此时取 X-Forwarded-For 中第一个IP得到的确实为客户端真实IP。<br><br></p><ul><li><strong>非正常访问时，在HTTP头中伪造XFF：</strong><br>客户端请求头中人为添加：X-Forwarded-For=192.168.1.1, 192.168.1.2，再看看结果：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"[proxy1]" 123.123.123.123 192.168.1.1, 192.168.1.2, 123.123.123.123 "GET /hello HTTP/1.1" 200</span><br><span class="line">"[proxy2]" 1.1.1.1 192.168.1.1, 192.168.1.2, 123.123.123.123, 1.1.1.1 "GET /hello HTTP/1.0" 200</span><br><span class="line">"[proxy3]" 2.2.2.2 192.168.1.1, 192.168.1.2, 123.123.123.123, 1.1.1.1, 2.2.2.2 "GET /hello HTTP/1.0" 200</span><br></pre></td></tr></table></figure></li></ul><p>由于 <code>$proxy_add_x_forward_for</code> 会继续追加Proxy1,Proxy2的ip1和ip2，所以真实IP0具体位置在哪里就不好判断了；</p><ul><li><strong>非正常访问，用户自己通过设置正向代理(普通匿名代理，高级匿名代理)的服务器访问目标：</strong><br>例如FQ，VPN之类的代理，访问目标服务器的请求完全由代理服务器发起，X-Forward-For的IP0 也是代理服务器的ip，所以无法判断用户真实ip;<br></li></ul><p>##X-Real-IP</p><p>是一个自定义头。X-Real-Ip 通常被 HTTP 代理用来表示与它产生 TCP 连接的设备 IP，这个设备可能是其他代理，也可能是真正的请求端。<br>需要注意的是，X-Real-Ip 目前并不属于任何标准，代理和 Web 应用之间可以约定用任何自定义头来传递这个信息。<br>没有相关标准，上面的例子，如果配置了X-Read-IP，可能会有两种情况:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 最后一跳是正向代理，可能会保留真实客户端IP</span><br><span class="line">X-Real-IP: 1.1.1.1(IP0)</span><br><span class="line">// 最后一跳是反向代理，比如Nginx，一般会是与之直接连接的客户端IP</span><br><span class="line">X-Real-IP: 3.3.3.3(IP2)</span><br></pre></td></tr></table></figure><p>所以 ，如果只有一层代理，这两个头的值就是一样的;<br>但是如果有多级代理，x-forwarded-for效果是大于x-real-ip的，x-forwarded-for可以记录完整的代理链路;</p><p>##To be continued…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;X-Forwarded-For简单理解&quot;&gt;&lt;a href=&quot;#X-Forwarded-For简单理解&quot; class=&quot;headerlink&quot; title=&quot;X-Forwarded-For简单理解&quot;&gt;&lt;/a&gt;X-Forwarded-For简单理解&lt;/h1&gt;&lt;h3 i
      
    
    </summary>
    
    
      <category term="To be continued..." scheme="http://yoursite.com/tags/To-be-continued/"/>
    
  </entry>
  
  <entry>
    <title>Python多线程的变量影响</title>
    <link href="http://yoursite.com/2019/07/15/py_threading/"/>
    <id>http://yoursite.com/2019/07/15/py_threading/</id>
    <published>2019-07-15T14:02:17.000Z</published>
    <updated>2019-07-16T15:09:18.806Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python多线程的变量影响"><a href="#Python多线程的变量影响" class="headerlink" title="Python多线程的变量影响"></a>Python多线程的变量影响</h1><h3 id="example1：sleep-控制多线程的变量"><a href="#example1：sleep-控制多线程的变量" class="headerlink" title="example1：sleep()控制多线程的变量"></a>example1：sleep()控制多线程的变量</h3><hr><p><strong>py代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">num = <span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work_1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    print(<span class="string">"work_1 ---- %d\n"</span> % num)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work_2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">        print(<span class="string">"work_2 ---- %d\n"</span> % num)</span><br><span class="line">        time.sleep(<span class="number">1</span>)<span class="comment">#sleep()控制了work_2线程顺序</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">"num最初：%d\n"</span> %num)</span><br><span class="line">    t_1 = threading.Thread(target=work_1)</span><br><span class="line">    t_2 = threading.Thread(target=work_2)</span><br><span class="line">    t_2.start()</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)<span class="comment">#sleep()控制了线程顺序</span></span><br><span class="line">    t_1.start()<span class="comment">#线程只能start一次</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"num最后：%d\n"</span> %num)</span><br></pre></td></tr></table></figure><p>通过运行结果，发现<code>work_2()</code>中的sleep(1)使得work_2的线程未执行完函数，num便被<code>work_1()</code>调用，所以work_1的num不是103；<br><br><br><img src="https://1j0ker.github.io/md_img/threading_1.jpg" alt="exmple1.md"><br><br></p><h3 id="example2：多线程各自非顺序计算对全局变量的影响"><a href="#example2：多线程各自非顺序计算对全局变量的影响" class="headerlink" title="example2：多线程各自非顺序计算对全局变量的影响"></a>example2：多线程各自非顺序计算对全局变量的影响</h3><p><br>—————————————————————————-<br><strong>py代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">g_num = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work_threading</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">     </span><br><span class="line">    print(<span class="string">"work_threading ---- %d\n"</span> % g_num)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    print(<span class="string">"work ---- %d\n"</span> % g_num)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">print(<span class="string">"创建多线程之前g_num: %d"</span>%g_num)</span><br><span class="line"></span><br><span class="line">t = threading.Thread(target=work_threading, args=(<span class="number">100000</span>,))</span><br><span class="line">t.start()</span><br><span class="line"><span class="comment">#time.sleep(1)</span></span><br><span class="line">work(<span class="number">100000</span>)</span><br></pre></td></tr></table></figure><p><em>看一下执行结果：</em></p><p><img src="https://1j0ker.github.io/md_img/threading_val2.jpg" alt="exmple2.md"><br><br><br>&#8195;&#8195;能看到，每次执行结果都可能都不相同，原因就是，<code>work_threading()</code>线程调用时使其独自计算，代码继续下读，到<code>work()</code>导致在未完成完整的函数计算时，被双方调用的g_num可能是非最终结果（正常计算应该是100000），造成了最后参数的混乱不一；<br><em>（<code>work()</code>也可以是多线程函数，这里用普通循环函数，便于对比和理解）</em><br><br><br>可以在<code>work_threading()</code>和<code>work()</code>中添加<code>sleep()</code>,确保函数调用的按序进行，也就是example1中的<code>sleep()</code>影响全局变量原因；<br><br><br><img src="https://1j0ker.github.io/md_img/threading_val3.jpg" alt="exmple3.md"></p><br>--------------<h3 id="test-1-多线程探测主机"><a href="#test-1-多线程探测主机" class="headerlink" title="test_1:多线程探测主机"></a>test_1:多线程探测主机</h3><p><em>测试一下我所在的ip段</em></p><p><strong>py代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#-*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line">import os#调用os模块，启动cmd</span><br><span class="line"></span><br><span class="line">code = os.popen(&apos;chcp 65001&apos;)#cmd的GBK编码问题，转成utf-8</span><br><span class="line"></span><br><span class="line">def Check_ip(ip):</span><br><span class="line">    cmd_ip = &apos;ping -n 1 xxx.xxx.xxx.&apos; + str(ip)# -n 1仅仅探测一个回包，速度更快</span><br><span class="line">    #print(cmd_ip)</span><br><span class="line">    check = os.popen(cmd_ip)</span><br><span class="line">    data = check.read()</span><br><span class="line">    #print(data)</span><br><span class="line">    if &apos;TTL&apos; in data:</span><br><span class="line">        print(&apos;%s is UP\n&apos; % cmd_ip)</span><br><span class="line">    time.sleep(0.5)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    for i in range(1,255):</span><br><span class="line">        t = threading.Thread(target=Check_ip, args=(i, ))</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;结果能感觉到，速度明显的加快，打印下进程：</p><p><img src="https://1j0ker.github.io/md_img/threading_checkip1.jpg" alt="exmple4.md"></p><p>###To be continued…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Python多线程的变量影响&quot;&gt;&lt;a href=&quot;#Python多线程的变量影响&quot; class=&quot;headerlink&quot; title=&quot;Python多线程的变量影响&quot;&gt;&lt;/a&gt;Python多线程的变量影响&lt;/h1&gt;&lt;h3 id=&quot;example1：sleep-控制
      
    
    </summary>
    
    
      <category term="To be continued..." scheme="http://yoursite.com/tags/To-be-continued/"/>
    
  </entry>
  
  <entry>
    <title>UTS安装时问题总结</title>
    <link href="http://yoursite.com/2019/07/12/UTS%E5%AE%89%E8%A3%85%E6%97%B6%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/07/12/UTS安装时问题总结/</id>
    <published>2019-07-12T12:39:30.332Z</published>
    <updated>2019-07-11T08:36:35.910Z</updated>
    
    <content type="html"><![CDATA[<p>在学习UTS安装时，会遇到各种各样的问题，安装完成后，对各种出现的问题需要自我总结。</p><h2 id="出现的问题及解决方案"><a href="#出现的问题及解决方案" class="headerlink" title="出现的问题及解决方案"></a>出现的问题及解决方案</h2><h3 id="一、DELL-R730-服务器"><a href="#一、DELL-R730-服务器" class="headerlink" title="一、DELL R730 服务器"></a>一、DELL R730 服务器</h3><h4 id="1-U盘安装centos-7-3："><a href="#1-U盘安装centos-7-3：" class="headerlink" title="1.    U盘安装centos 7.3："></a>1.    U盘安装centos 7.3：</h4><p>a)    DELL R730 F11进入BIOS，设置UEFI后，重启后再次进入F11，BIOS中选择从USB启动，开始安装Centos 7;</p><p>b)    Centos 安装界面时，按e进入编辑，修改成正确的U盘名称：sd*，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /dev#第一次无法查看，失败一次后，命令行查看自己的U盘名称</span><br></pre></td></tr></table></figure><p>安装路径改为 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">… … =hd: /dev/sd* quiet</span><br></pre></td></tr></table></figure><p>c)    Centos 安装过程中，手动分区问题：</p><pre><code>①确认正确的 File system 后，记得Update;②**/home**分区问题：有几块盘，就分几个**/home/sd*** 子目录，最后加上/home目录;</code></pre><p>d)    Centos安装完成后：强制常见User用户，建议系统启动后锁个屏，然后更换为/root用户登录；（防止UTS文件解压后，放入/home下，却发现实际在/home/User下，造成安装脚本的运行失败；</p><h4 id="2-UTS-脚本配置："><a href="#2-UTS-脚本配置：" class="headerlink" title="2.    UTS 脚本配置："></a>2.    UTS 脚本配置：</h4><p>a)    UTS参数配置时，注意绑定的网卡(如<strong>em3</strong>)，后面选择透传网卡时不会再出现在选择列表；</p><p>b)    在运行UTS安装脚本前，建议最大化终端，否则可能会出现分辨率显示不全问题；（在选择透传网卡）;</p><p>c)    脚本安装完成后，提示<strong>reboot</strong>，再确认无error：后再重启；（syn…error脚本中语法错误可忽略）;</p><p>d)    重启后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virsh list –all#先确定uts_01是否runing</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virsh console uts_01#在开始控制UTS虚拟机</span><br></pre></td></tr></table></figure><hr><h3 id="二、重点注意问题"><a href="#二、重点注意问题" class="headerlink" title="二、重点注意问题"></a>二、重点注意问题</h3><ol><li>在执行UTS参数确定网卡安装脚本后，网卡与网桥绑定，不易卸载网桥；<br>（可进入/<strong>etc/sysconfig/network_config/vibr0</strong>处修改网桥ip）</li></ol><p>2    . 重装虚拟机：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a)virsh shutdown uts_01#关闭当前虚拟机uts_01</span><br><span class="line">virsh undefine uts_01#卸载现有虚拟机uts_01</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b)rm –r 现在虚拟机生成的.img#删除uts_01生成的镜像文件；</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c)重新执行安装脚本；</span><br></pre></td></tr></table></figure><p>3    . 注意参数配置的，分配内存的大小，太大时，在UTS的web端进行系统或规则包升级时，容易造成卡死。重启UTS虚拟机；</p><p>4    . 安装完成UTS后，web端访问无流量显示：</p><pre><code>a)    查看接口信息，是否接口网桥未开启；b)    联动安装TAM，查看是否已有事件生成，如果有，则是可能是接口显示问题，建议联系开发查看；</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在学习UTS安装时，会遇到各种各样的问题，安装完成后，对各种出现的问题需要自我总结。&lt;/p&gt;
&lt;h2 id=&quot;出现的问题及解决方案&quot;&gt;&lt;a href=&quot;#出现的问题及解决方案&quot; class=&quot;headerlink&quot; title=&quot;出现的问题及解决方案&quot;&gt;&lt;/a&gt;出现的问题及
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Python爬虫闯关练习</title>
    <link href="http://yoursite.com/2019/07/11/py-spiders1/"/>
    <id>http://yoursite.com/2019/07/11/py-spiders1/</id>
    <published>2019-07-11T10:02:17.000Z</published>
    <updated>2019-07-12T13:08:00.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python爬虫闯关练习"><a href="#Python爬虫闯关练习" class="headerlink" title="Python爬虫闯关练习"></a>Python爬虫闯关练习</h1><p>黑板客爬虫闯关<a href="http://www.heibanke.com/lesson" target="_blank" rel="noopener">http://www.heibanke.com/lesson</a></p><h2 id="第一关"><a href="#第一关" class="headerlink" title="第一关"></a>第一关</h2><h3 id="连续爬取数据并get传参"><a href="#连续爬取数据并get传参" class="headerlink" title="连续爬取数据并get传参"></a>连续爬取数据并get传参</h3><p>&#8195;<em>先试着输入几次参数，了解题目目标</em><br><img src="https://1j0ker.github.io/md_img/py_zj1.png" alt="exmple1.md"></p><p><strong>思路：</strong>每次输入指定数字后会要求新的get参数，所以需要不断的匹配数字然后提交；<br>    利用模块<code>requests  和    re模块</code><br>这里查看网页源码，可以清晰的看到需要匹配的字段特征：<br><img src="https://1j0ker.github.io/md_img/py_zj2.png" alt="exmple2.md"></p><hr><p><strong>py代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://www.heibanke.com/lesson/crawler_ex00/'</span></span><br><span class="line">r = requests.get(url=url)</span><br><span class="line"></span><br><span class="line">numbers = re.findall(<span class="string">r'&lt;h3&gt;你需要在网址后输入数字([\d]&#123;5&#125;)'</span>,r.text)</span><br><span class="line"><span class="comment">#print(numbers)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> numbers:</span><br><span class="line">    url = <span class="string">'http://www.heibanke.com/lesson/crawler_ex00/%s/'</span> % numbers[<span class="number">0</span>]</span><br><span class="line">    print(url)</span><br><span class="line">    html = requests.get(url=url)</span><br><span class="line">    numbers = re.findall(<span class="string">r'数字是([\d]&#123;5&#125;)'</span>,html.text)<span class="comment">#通过更新数字，来判断循环的终止</span></span><br><span class="line">    <span class="keyword">print</span> (numbers)</span><br><span class="line"><span class="keyword">else</span>:    </span><br><span class="line">    print(html.text)<span class="comment">#最后过关的页面</span></span><br></pre></td></tr></table></figure><hr><h2 id="最终密码：0第二关"><a href="#最终密码：0第二关" class="headerlink" title="最终密码：0第二关"></a><strong>最终密码：0</strong><br><br><br>第二关</h2><h3 id="POST型传参"><a href="#POST型传参" class="headerlink" title="POST型传参"></a>POST型传参</h3><p><img src="https://1j0ker.github.io/md_img/py_zj3.png" alt="exmple3.md"><br><em>随便输入尝试一下，发现报错信息：</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>这里是黑板客爬虫闯关的第二关<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>您输入的密码错误, 请重新输入<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br><br><br><strong>思路：</strong>正常的登录页面，很明显是<strong>POST</strong>传表单,再加上循环取值就行；<br>同样匹配判断是否包含错误信息，来终止循环；<br>使用模块<code>requests  和    re模块</code></p><hr><p><strong>py代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://www.heibanke.com/lesson/crawler_ex01/'</span></span><br><span class="line">html = requests.post(url=url, data=&#123;<span class="string">'username'</span>:<span class="string">'ads'</span>,<span class="string">'password'</span>:<span class="number">1</span>&#125;)</span><br><span class="line">char = re.findall(<span class="string">'密码错误'</span>,html.text)</span><br><span class="line">print(char)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">for psd in range(30):</span></span><br><span class="line"><span class="string">    print (psd)</span></span><br><span class="line"><span class="string">    html = requests.post(url=url, data=&#123;'username':'ads','password':psd&#125;)</span></span><br><span class="line"><span class="string">    if '密码错误' not in html.text:</span></span><br><span class="line"><span class="string">        print('password =',psd)</span></span><br><span class="line"><span class="string">        break</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.while使用</span></span><br><span class="line">psd = <span class="number">-2</span></span><br><span class="line"><span class="keyword">while</span> char <span class="keyword">and</span> psd &lt; <span class="number">30</span>:</span><br><span class="line">    <span class="keyword">print</span> (psd)</span><br><span class="line">    html = requests.post(url=url, data=&#123;<span class="string">'username'</span>:<span class="string">'ads'</span>,<span class="string">'password'</span>:psd&#125;)</span><br><span class="line">    char = re.findall(<span class="string">'密码错误'</span>,html.text)</span><br><span class="line">    psd +=<span class="number">1</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">'password ='</span>,psd<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><p><strong>最终密码：4</strong></p><hr><p><br><br></p><h2 id="第三关"><a href="#第三关" class="headerlink" title="第三关"></a>第三关</h2><h3 id="验证登录以及从爬虫保持Token访问"><a href="#验证登录以及从爬虫保持Token访问" class="headerlink" title="验证登录以及从爬虫保持Token访问"></a>验证登录以及从爬虫保持Token访问</h3><p><em>进入第三关的链接<a href="http://www.heibanke.com/lesson/crawler_ex02/" target="_blank" rel="noopener">http://www.heibanke.com/lesson/crawler_ex02/</a><br>但是跳转到了<code>login</code>登陆页面,一开始以为在线的题目出错了，但注册完在登陆进去之后，才明白题目确实是这样的要求：</em><br><img src="https://1j0ker.github.io/md_img/py_zj4.png" alt="exmple4.md"><br>注册登录后，发现题目：<br><img src="https://1j0ker.github.io/md_img/py_zj5.png" alt="exmple5.md"><br><br><br>和第二关很像，用第二关的代码改了下<code>url</code>在运行，出现了问题：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"summary"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Forbidden <span class="tag">&lt;<span class="name">span</span>&gt;</span>(403)<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>CSRF verification failed. Request aborted.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>发现了访问拒绝，又是<strong>POST</strong>包，这时候要去看一看<strong>request</strong>里面post哪些东西？<br><img src="https://1j0ker.github.io/md_img/py_zj6.png" alt="exmple6.md"><br>很明显多了个<code>token值</code>，再仔细查看，是<strong>request</strong>里cookies的这个值<code>csrftoken=2m7tnWxAV9Bm9lfFjWQ3vvCxAvY3qSxe;</code><br><br><br>那现在问题是这个token值是怎么获得的？经过一番F12是访问题目页面时，<strong>respond</strong>里的<code>Set-Cookie: csrftoken=2m7tnWxAV9Bm9lfFjWQ3vvCxAvY3qSxe;</code>由服务器发送给我们，用来验证接下来我们操作的身份；<br><br><br>也就是说，我们要在<strong>POST</strong>数据时，首先爬取<code>csrftoken</code>值，然后将<code>token</code>一同传过去；</p><hr><p>py代码(这次就没用<code>re</code>模块了)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url_1 = <span class="string">'http://www.heibanke.com/accounts/login'</span></span><br><span class="line">url_2 = <span class="string">'http://www.heibanke.com/lesson/crawler_ex02/'</span></span><br><span class="line">s = requests.Session()  <span class="comment">#创建会话，保存token</span></span><br><span class="line"></span><br><span class="line">s.get(url_1)</span><br><span class="line">token_1 = s.cookies[<span class="string">'csrftoken'</span>]<span class="comment">#get登录，拿到当前token</span></span><br><span class="line">print(token_1)</span><br><span class="line">data_1 = &#123;</span><br><span class="line">    <span class="string">'username'</span>: <span class="string">'efre'</span>,<span class="comment">#注册过的账号</span></span><br><span class="line">    <span class="string">'password'</span>: <span class="string">'123456123456'</span>,</span><br><span class="line">    <span class="string">'csrfmiddlewaretoken'</span>: token_1,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">s.post(url_1,data=data_1)<span class="comment">#登录</span></span><br><span class="line"><span class="comment">#print(r.text)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data_2 = &#123;</span><br><span class="line">    <span class="string">'username'</span>:<span class="string">'admin'</span>,</span><br><span class="line">    <span class="string">'password'</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="string">'csrfmiddlewaretoken'</span>:<span class="string">''</span>,</span><br><span class="line">    &#125;</span><br><span class="line">s.post(url_2)<span class="comment">#获取题目页面的初始token值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pwd <span class="keyword">in</span> range(<span class="number">31</span>):</span><br><span class="line">    token_2 = s.cookies[<span class="string">'csrftoken'</span>]</span><br><span class="line">    data_2[<span class="string">'csrfmiddlewaretoken'</span>]=token_2</span><br><span class="line">    data_2[<span class="string">'password'</span>]=pwd</span><br><span class="line">    print(pwd,<span class="string">'+'</span>,token_2)<span class="comment">#查看当前密码和当前token值</span></span><br><span class="line">    html = s.post(url_2, data=data_2)</span><br><span class="line">    <span class="comment">#print(html.text)</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'密码错误'</span> <span class="keyword">not</span> <span class="keyword">in</span> html.text:</span><br><span class="line">        <span class="comment">#print(html.text)</span></span><br><span class="line">        print(<span class="string">'password ='</span>,pwd)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p><strong>最终密码：21</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Python爬虫闯关练习&quot;&gt;&lt;a href=&quot;#Python爬虫闯关练习&quot; class=&quot;headerlink&quot; title=&quot;Python爬虫闯关练习&quot;&gt;&lt;/a&gt;Python爬虫闯关练习&lt;/h1&gt;&lt;p&gt;黑板客爬虫闯关&lt;a href=&quot;http://www.hei
      
    
    </summary>
    
    
      <category term="To be continued..." scheme="http://yoursite.com/tags/To-be-continued/"/>
    
  </entry>
  
</feed>
